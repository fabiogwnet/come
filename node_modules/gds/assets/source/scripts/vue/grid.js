axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';

Vue.component('gds-grid', {
  props: {
    simpleGrid: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      required: true
    },
    url: {
      type: String,
      required: true
    },
    axiosInstance: {
      type: Function,
      default: axios
    },
    params: {
      type: Object,
      default () {
        return {}
      }
    },
    groupBy: {
      type: Array,
      default: () => []
    },
    groupLabel: {
      type: String,
      default: ''
    },
    lazyUrl: {
      type: String,
      default: ''
    },
    lazyKey: {
      type: String,
      default: ''
    },
    lazyValue: {
      type: String,
      default: 'id'
    },
    childrensUrl: {
      type: String,
      default: ''
    },
    childrensKey: {
      type: String,
      default: ''
    },
    childrensParentKey: {
      type: String,
      default: 'id'
    },
    autoload: {
      type: Boolean,
      default: true
    },
    datatype: {
      type: String,
      default: 'json'
    },
    method: {
      type: String,
      default: 'post'
    },
    formId: {
      type: String,
      default: ''
    },
    filterData: {
      type: Function,
      default(rows, gridInstance) {
        return rows;
      }
    },
    filterLazyData: {
      type: Function,
      default(row) {
        return row;
      }
    },
    checkboxAll: {
      type: Boolean,
      default: false
    },
    order: {
      type: String,
      required: true
    },
    orderDirection: {
      type: String,
      default: 'ASC'
    },
    columns: {
      type: Array,
      required: true
    },
    column: {
      type: Object,
      default () {
        return {
          width: 180
        }
      }
    },
    pagination: {
      type: Boolean,
      default: true
    },
    pageSizeInit: {
      type: Number,
      default: 10
    },
    pageSizeItems: {
      type: Array,
      default () {
        return [10, 25, 50]
      }
    },
    border: {
      type: Boolean,
      default: false
    },
    small: {
      type: Boolean,
      default: false
    },
    stripes: {
      type: Boolean,
      default: false
    },
    userSettings: {
      type: Object,
      default () {
        return {}
      }
    },
    onMount: {
      type: Function,
      default(gridInstance) {}
    },
    onBeforeFetch: {
      type: Function,
      default(gridInstance) {}
    },
    onComplete: {
      type: Function,
      default(gridInstance) {}
    },
    onUpdate: {
      type: Function,
      default(gridInstance) {}
    },
    onCompleteChildrenRow: {
      type: Function,
      default(gridInstance, row) {}
    },
    onCompleteLazyRow: {
      type: Function,
      default(gridInstance, row) {}
    },
    errorMessage: {
      type: Object,
      default () {
        return {
          'title': 'Não foi possível carregar os dados.',
          'subtitle': 'Atualize a página e tente novamente.'
        }
      }
    },
    autoloadMessage: {
      type: Object,
      default () {
        return {
          'title': 'Os dados não foram carregados.',
          'subtitle': 'Faça um filtro para atualizar.'
        }
      }
    },
    emptyMessage: {
      type: Object,
      default () {
        return {
          'title': 'Nenhum resultado foi encontrado.',
          'subtitle': 'Tente filtrar por outro período ou um período maior.'
        }
      }
    },
    loadingMessage: {
      type: Object,
      default () {
        return {
          'title': 'Carregando os dados...',
          'subtitle': 'Aguarde enquanto buscamos as informações.'
        }
      }
    }
  },
  data: function () {
    return {
      currentPage: 1,
      totalPages: 0,
      totalData: 0,
      pageSize: this.pageSizeInit,

      formEl: this.formId ? document.getElementById(this.formId) : false,
      formData: [],
      orderKey: this.order || '',
      orderSort: ( this.order && this.orderDirection ) ? this.orderDirection : '',

      bodyScrolledRight: false,
      bodyScrolledLeft: true,
      offsetHead: 0,
      fixedHead: false,
      wrapperWidth: '100%',
      
      loadingDone: true,
      displayError: false,
      responseData: [],
      loadUserSettingsDone: false,
      rowsWasFetched: false,
   
      rowHover: -1,
      rows: [],
      cols: this.columns.filter((th) => {
        return !th.disable;
      }),
      colsLocked: this.columns.filter((th) => {
        return th.lock && !th.disable;
      }),
      colsDropdown: JSON.parse(JSON.stringify(this.columns.filter((th) => {
        return !th.disable;
      }))),
      colsOrder: this.columns.filter((th) => {
        return !th.disable;
      }).map(col => col.value),
      
      rowHeight: 0,
      selectedRows: [],
      checkedRows: [],
      checkedAll: false,

      minVisibleColumns: 2,
      maxFrozenColumns: 4,
      hiddenColumns: this.columns.filter((col) => {  return !col.disable && col.hidden; }).map(col => col.value),
      frozenColumns: this.columns.filter((th) => {
        return th.freeze && !th.disable;
      }).map(col => col.value),
   

      actionsWidth: 50,
      counter: false,
      counterStart: 1,
      bordered: this.border,
      striped: this.stripes,
      hover: true,
      sm: this.small,
      fullscreen: false,
      fullwidth: false,
      containerClass: 'container'
    }
  },
  computed: {
    checkedRowsIds() {
      return this.checkedRows.map(row => row.id);
    },
    screenWidth() {
      return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
    },
    screenHeight() {
      return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    }
  },
  filters: {

  },
  methods: {
    fetchRows: function() {
      this.loadingDone = false;
      this.displayError = false;
      this.rowsWasFetched = true;

      this.trigger('beforeFetch');

      this.axiosInstance({
        url : this.url,
        method : this.method,
        data : this.getFormData(),
        params : this.getParams()
      })
        .then(response => {
          var rows;
          rows = this.filterData(response.data.data, this);
          rows = this.groupRows(rows);

          this.rows = rows;
          this.totalData = response.data.total;
          this.totalPages = Math.ceil( this.totalData / this.pageSize );
          this.loadingDone = true;
          this.responseData = response.data;
          this.checkedAll = false;
          this.checkedRows = [];
          this.unoverflowCells();

          this.trigger('complete');

          if( this.lazyUrl != '' ) {
            this.fetchLazyRows();
          }
        })
          .catch(error => {
              console.error(error);
              this.rows = [];
              this.displayError = true;
              this.loadingDone = true;
          });
    },
    fetchLazyRows: function() {
      this.rows.forEach((row) => {

        this.axiosInstance({
          url : this.lazyUrl,
          method : this.method,
          data : this.getFormData(this.lazyKey, row[this.lazyValue]),
          params : this.getParams()
        })
          .then(response => {
              delete response.data.id;
              var currentRow = this.filterLazyData(response.data);

              Object.keys(currentRow).map((key) => {
                this.$set(row, key, currentRow[key]);
              });

              this.$set(row, 'lazyDone', true);
              
              this.trigger('completeLazyRow');
          })
            .catch(error => {
                console.error(error);
                this.rows = [];
                this.displayError = true;
                this.lazyDone = true;
            });
      });
    },
    fetchChildrensRows: function(row) {
      this.loadingDone = false;
      
      this.axiosInstance({
        url : this.childrensUrl,
        method : this.method,
        data : this.getFormData(this.childrensKey, row[this.childrensParentKey]),
        params : this.getParams()
      })
        .then(response => {
          var rowIndex = this.rows.indexOf(row);

          this.filterData(response.data.data).forEach((children) => {
            children.isChildren = true;
            this.rows.splice(++rowIndex, 0, children);
          });

          this.loadingDone = true;

          this.trigger('completeChildrenRow');
        })
          .catch(error => {
              console.error(error);
              this.displayError = true;
              this.loadingDone = true;
          });
    },
    getFormData: function(key, value) {
      var requestFormData = this.formEl ? new FormData(this.formEl) : new FormData();

      if( !key ) {
        requestFormData.append('ordination', this.orderKey + ' ' + this.orderSort);
        requestFormData.append('paginate', this.pageSize);
        requestFormData.append('page', this.currentPage);
      } else {
        requestFormData.append(key, value);
      }

      var formData = {};
      for(var pair of requestFormData.entries()) {
        formData[pair[0]] = pair[1];
      }
      this.formData = formData;

      return requestFormData;
    },
    getParams: function() {
      return { ...this.params, ordination: this.orderKey + ' ' + this.orderSort, paginate: this.pageSize, page: this.currentPage }
    },

    nextPage: function() {
      if((this.currentPage*this.pageSize) < this.totalData) this.currentPage++;
    },
    prevPage: function() {
      if(this.currentPage > 1) this.currentPage--;
    },
    firstPage: function() {
      this.currentPage = 1;
    },
    lastPage: function() {
      this.currentPage = this.totalPages;
    },
    pageLinks: function() {
      var pageLinks = [];
      var pageRange = this.isMobile() ? 1 : 2;
      var pageOffset = ((pageRange*2)+1);
      var minPage = (this.currentPage - pageRange) > 0 ? this.currentPage - pageRange : 1;
      var maxPage = (this.currentPage + pageRange) <= this.totalPages ? (this.currentPage + pageRange) : this.totalPages ;
      
      if( ((maxPage - minPage)+1) < pageOffset) {
        maxPage = minPage + (pageOffset - 1);

        if( maxPage > this.totalPages ) {
          maxPage = this.totalPages;
        }
      }

      if( ((maxPage - minPage)+1) < pageOffset) {
        minPage = maxPage - (pageOffset - 1);

        if( minPage < 1 ) {
          minPage = 1;
        }
      }

      for(i = minPage; i <= maxPage; i++) {
        pageLinks.push({
          'number': i,
          'isCurrent': i == this.currentPage
        });
      }
      return pageLinks;
    },

    orderBy: function (col) {
      if( !col.orderable || this.rows.length == 0 )
        return;

      var orderKey = col.orderKey || col.value;

      if( orderKey == this.orderKey ) {
        this.orderSort = this.orderSort == 'ASC' ? 'DESC' : 'ASC';
      }

      this.orderKey = col.orderKey ? col.orderKey : col.value
    },
    orderClass: function (col) {
      var sortClass = 'fad fa-sort';
      var sortKey = col.orderKey || col.value;

      if( sortKey == this.orderKey ) {
        if( this.orderSort == 'ASC' ) {
          sortClass = 'fad fa-sort-up';
        } else {
          sortClass = 'fad fa-sort-down';
        }
      }

      return sortClass;
    },

    groupRows: function(rows) {
      if( !this.groupBy.length ) {
        return rows;
      }

      var lastGroup = '';
      var rowClass = 'g-tr-odd';
      var newGroup;
      var rowParent;
      var newsGroups = [];

      rows.forEach((row, i) => {
        newGroup = '';
        
        this.groupBy.forEach((key) => {
          newGroup += row[key];
        });

        if( newGroup != lastGroup ) {
          if( this.groupLabel == '' ) {
            rowClass = rowClass == 'g-tr-odd' ? 'g-tr-even' : 'g-tr-odd';
            row.class = rowClass;
          } else {
            rowParent = { label: row[this.groupLabel], key: newGroup, isParent: true, class: 'g-parent', position: i, children: [row] };
            newsGroups.push(rowParent);
            row.class = 'g-children';
          }
        } else {
          if( this.groupLabel != '' ) {
            row.class = 'g-children';
            newsGroups[ newsGroups.length - 1 ].children.push(row);
          } else {
            row.class  = rowClass;
          }
        }
        
        lastGroup = newGroup;
      });

      newsGroups.forEach((row, i) => {
        rows.splice(row.position + i, 0, row);
      });

      return rows;
    },

    sortColumn: function(value, newPosition, freeze) {
      const oldPosition = this.cols.map(function(col) { return col.value; }).indexOf(value);
      const movedCol = this.cols.find((col, index) => index === oldPosition);

      if( !freeze ) {
        if( movedCol.freeze ) {
          this.toggleFreezeColumn(movedCol)
        }
      } else {
        if( !movedCol.freeze ) {
          this.toggleFreezeColumn(movedCol)
        }
      }

      const deletedCol = this.cols.splice(oldPosition, 1)
      this.cols.splice(newPosition, 0, deletedCol[0]);
      this.colsOrder = this.cols.map(function(col) { return col.value });
    },

    toggleColumns: function(columnDropdown) {
      if( columnDropdown.lock ) {
        return;
      }
      
      const index = this.hiddenColumns.indexOf(columnDropdown.value);

      if( index > -1 ) {
        this.showColumn(columnDropdown.value)
      } else {
        this.hideColumn(columnDropdown.value)
      }
    },
    showColumn: function(name) {
      const index = this.hiddenColumns.indexOf(name);
      if( index == -1 ) {
        return
      }

      const columnList = this.cols.find((col, index) => col.value === name);
      const columnDropdown = this.colsDropdown.find((col, index) => col.value === name);

      columnList.hidden = false;
      columnDropdown.hidden = false;
      this.hiddenColumns.splice(index, 1);
    },
    hideColumn: function(name) {
      const index = this.hiddenColumns.indexOf(name);
      if( index > -1 ) {
        return
      }

      const columnList = this.cols.find((col, index) => col.value === name);
      const columnDropdown = this.colsDropdown.find((col, index) => col.value === name);

      columnList.hidden = true;
      columnDropdown.hidden = true;
      this.hiddenColumns.push(name);
    },
    lockFilterVisibleColumn: function(column) {
      var visibleDefrostedColumns = this.defrostedColumns().filter((col) => {
        return this.hiddenColumns.indexOf(col) == -1;
      });

      return visibleDefrostedColumns.length <= this.minVisibleColumns && this.hiddenColumns.indexOf(column.value) == -1 && !column.freeze;
    },
    isMobile: function(){
      return window.innerWidth < 768;
    },
    isVisibleCol: function(col){
      return !col.hidden && col.disable != true
    },
    defrostedColumns: function() {
      var defrostedColumns = this.cols.map(col => col.value).filter((col) => {
        return this.frozenColumns.indexOf(col) < 0;
      });

      return defrostedColumns;
    },
    toggleFreezeColumn: function(column) {
      if( column.lock ) {
        return;
      }

      if( !column.freeze ) {
        var index = this.defrostedColumns().indexOf(column.value);
        this.frozenColumns.push(column.value);
        column.freeze = true;
      } else {
        var index = this.frozenColumns.indexOf(column.value);
        this.frozenColumns.splice(index, 1);
        column.freeze = false;
      }
      
    },
    lockFilterFrozenColumn: function(column) {
      return this.frozenColumns.length >= this.maxFrozenColumns && !column.freeze;
    },

    expandCell: function(event, movableParent) {
      var cell = event.target;
      var text = cell.children[0];
      var row = cell.parentElement;

      if( !text ) {
        return;
      }

      if( text.offsetWidth >= (cell.offsetWidth - 34 ) || cell.classList.contains("overflow") ) { // 34 padding e diferença ...
        cell.classList.add('expand');

        if( cell.classList.contains("overflow") && !cell.classList.contains("overflowed") ) {
          cell.classList.add('overflowed');
        }

        var index = 0;
        while ( (row = row.previousElementSibling) ) {
          index++;
        }

        var frozenBodyOffset = 0;
        if( this.$refs.frozenBody ) {
          frozenBodyOffset = this.$refs.frozenBody.offsetWidth;
        }

        var left = !movableParent ? cell.offsetLeft : (cell.offsetLeft - this.$refs.movableBody.scrollLeft ) + frozenBodyOffset;
        text.style.left = left + 'px';
        text.style.top = cell.offsetTop + 'px';
        text.style.width = cell.offsetWidth + 'px';
        text.style.minHeight = this.rowHeight + 'px';

        if( index > Math.ceil( ( this.rows.length / 2 ) - 1 ) ) {
          // cell.classList.add('up');
        }
      }
    },
    unfoldCell: function(event) {
      var cell = event.target;
      cell.classList.remove('expand', 'up');
    },
    unoverflowCells: function() {
      var frozenBodyOffset = 0;
      if( this.$refs.frozenBody ) {
        frozenBodyOffset = this.$refs.frozenBody.offsetWidth;
      }

      if( this.$refs.movableBody ) {
        var movableRows = this.$refs.movableBody.querySelectorAll('tr');
        movableRows.forEach((row) => {
          var movableCells = row.querySelectorAll('td');
          movableCells.forEach((cell) => {
            // var text = cell.children[0];
            // var left = (cell.offsetLeft - this.$refs.movableBody.scrollLeft ) + frozenBodyOffset;
            // text.style.left = left + 'px';
            Object.values(GDS.tail.selects).forEach((select) => {
              if( select ) {
                select.close();
              }
            });

            if( cell.classList.contains("overflow") && cell.classList.contains("overflowed") ) {
              cell.classList.remove('overflowed');
            }
         });
        });
      }
    },
    selectRow: function(row) {
      var indexRow = this.selectedRows.indexOf(JSON.stringify(row));

      if( indexRow > -1 ) {
        this.selectedRows.splice(indexRow, 1);
      } else {
        this.selectedRows.push(JSON.stringify(row));
      }

      this.expandRow(row);
    },
    selectedRow: function(row) {
      return this.selectedRows.indexOf(row) > -1;
    },
    expandRow: function(row) {
      if( !this.childrensUrl ) {
        return;
      }

      if( !row.isChildren ) {
        if( !row.expanded ) {
          row.expanded = true;
          this.fetchChildrensRows(row);
        } else {
          this.rows = this.rows.filter(( item ) => {
            return item[this.childrensKey] != row[this.childrensParentKey];
          });

          row.expanded = false;
        }
      }
    },

    getTableWidth: function (columns){
      var columns_objects = this.cols.filter((column) => {
        return columns.indexOf(column.value) > -1
      });

      var tableWidth = 0;
      columns_objects.map((column) => {
        if( !column.hidden ) {
          tableWidth += column.width ? column.width : this.column.width
        }
      });

      return tableWidth + 'px';
    },
    getTableClass: function() {
      return {
        'table-striped': this.striped,
        'table-hover': this.hover,
        'table-sm': this.sm,
        'table-bordered': this.bordered
      };
    },
    getRowClass: function(row, i) {
      var classes = {
        'hover': this.rowHover == i,
        'g-children': row.isChildren,
        'g-parent': !row.isChildren && this.childrensUrl,
        'expanded': row.expanded,
        'selected': this.selectedRows.indexOf(JSON.stringify(row)) > -1
      }

      if( row.class ) {
       classes[row.class] = row.class;
      }

      return classes;
    },

    saveUserSettings: function(){
      if( !this.loadUserSettingsDone ) {
        return;
      }

      var settings = { 
        striped: this.striped,
        bordered: this.bordered,
        fullwidth: this.fullwidth,
        sm: this.sm,
        pageSize: parseInt(this.pageSize),
        counter: this.counter,
        hiddenColumns: this.hiddenColumns,
        frozenColumns: this.frozenColumns,
        colsOrder: this.colsOrder
      };

      var requestFormData = new FormData();
      requestFormData.append('module_name', pageInfo.module_name);
      requestFormData.append('action_name', pageInfo.action_name);
      requestFormData.append('table_columns', JSON.stringify(settings));

      axios({
        url : '/ajax-save-default-table_fields',
        method : 'post',
        data : requestFormData
      })
        .then(response => {
          // console.info('User table settings saved.')
        })
          .catch(error => {
              console.error(error);
          });
    },
    loadUserSettings: function(){
      new Promise((resolve, reject) => {
        
        if( Object.keys(this.userSettings).length ) {

          // Atualiza as configurações da tabela
          Object.keys(this.userSettings).map((key) => {
            this[key] = this.userSettings[key];
          });

          // Atualiza os parametros das colunas
          this.cols.map(column => {
            column.hidden = this.hiddenColumns.indexOf(column.value) > -1;
            column.freeze = this.frozenColumns.indexOf(column.value) > -1;
          });

          // Ordena as colunas
          var orderedCols = [];
          this.colsOrder.forEach( (value, i) => {
            var col = this.cols.find((col, index) => col.value === value);
            if( col ) {
              orderedCols.push(col);
            }
          });

          // Adiciona as colunas novas ainda não ordenadas
          this.cols.forEach( (col, i) => {
            if( orderedCols.indexOf(col) == -1 ) {
              orderedCols.push(col);
            }
          });

          this.cols = orderedCols;
          this.colsDropdown = JSON.parse(JSON.stringify(this.cols));
        
        }
        
        resolve();

      }).then(() => {
        this.loadUserSettingsDone = true;
      });
    },
    handleFormSubmit: function(e) {
      e.preventDefault();
      this.currentPage = 1;
      this.fetchRows();
    },
    handleBodyScroll: function() {
      var $movableBody =  this.$refs.movableBody;
      var $movableHead =  this.$refs.movableHead;

      var percentage = $movableBody.scrollLeft / ($movableBody.scrollWidth - $movableBody.offsetWidth);
      $movableHead.scrollLeft = percentage * ($movableHead.scrollWidth - $movableHead.offsetWidth);

      if( $movableBody.scrollLeft == 0 ) {
        this.bodyScrolledRight = false;
      } else {
        this.bodyScrolledRight = true;
      }

      if( percentage == 1 ) {
        this.bodyScrolledLeft = false;
      } else {
        this.bodyScrolledLeft = true;
      }

      this.unoverflowCells();
    },
    handleWindowScroll: function(){
      if( this.fullscreen ) {
        this.offsetHead = 0;
        return;
      }

      var offsetWindow = window.pageYOffset || document.documentElement.scrollTop;
      var headerHeight = document.getElementById('top-new') ? document.getElementById('top-new').offsetHeight : 0;
      var offsetWrapper = this.getPositionTop(this.$refs.wrapper) - headerHeight;

      if( offsetWindow > offsetWrapper ) {
        var totalOffset = this.$el.offsetHeight + offsetWrapper - (this.$refs.head.offsetHeight * 2);
        
        if( offsetWindow >= totalOffset ) {
          this.offsetHead = 0;
          this.fixedHead = false;
          return;
        }

        this.offsetHead = offsetWindow - offsetWrapper;
        this.fixedHead = true;
      } else if( offsetWindow <= offsetWrapper ) {
        this.offsetHead = 0;
        this.fixedHead = false;
      }
    },
    getPositionTop: function(element) {
      var yPosition = 0;
  
      while(element) {
          yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
          element = element.offsetParent;
      }
  
      return yPosition;
    },
    resize: function (){
       this.$nextTick(() => {
        this.wrapperWidth = this.$refs.wrapper.offsetWidth + "px";
        this.$refs.wrapper.style.paddingTop = this.$refs.head.offsetHeight + "px";

        var $movableBody =  this.$refs.movableBody;
        if( $movableBody.scrollWidth == $movableBody.offsetWidth) {
          this.bodyScrolledLeft = false;
        } else {
          this.bodyScrolledLeft = true;
        }
     
        var rowMaxHeight = this.rowHeight;
        
        if( this.$refs.frozenBody ) {
          var frozenRows = this.$refs.frozenBody.querySelectorAll('tr');
          frozenRows.forEach((row) => {
            if(row.offsetHeight > rowMaxHeight)
              rowMaxHeight = row.offsetHeight;
          });
        }

        if( this.$refs.movableBody ) {
          var movableRows = this.$refs.movableBody.querySelectorAll('tr');
          movableRows.forEach((row) => {
            if(row.offsetHeight > rowMaxHeight)
              rowMaxHeight = row.offsetHeight;
          });
        }

        this.rowHeight = rowMaxHeight;

        window.dispatchEvent(new Event('resize'));
      });
    },
    dragColumns: function() {
      var dropdown =  this.$refs.dropdown;
      
      if( !dropdown ) {
       return;
      }

      const gridInstance = this;
  
      var dropzoneFrozen = dropdown.querySelectorAll('.dropzone-frozen');
      var dropzoneDefrosted = dropdown.querySelectorAll('.dropzone-defrosted');
      var dropzoneLocked = dropdown.querySelectorAll('.dropdown-locked-items');

      var dropSettings = {
        group: 'shared',
        animation: 150,
        // handle: '.fa-arrows',
        draggable: '.dropdown-item',
        onSort: function () {
        },
        onMove: function(event) {
          var frozenDropzone = event.to.classList.contains('dropzone-frozen');
          var fromFrozenDropzone = event.from.classList.contains('dropzone-frozen');
          var limitExceeded = (event.to.querySelectorAll('.dropdown-item:not(.sortable-ghost)').length +  gridInstance.colsLocked.length) >= gridInstance.maxFrozenColumns;

          if( frozenDropzone && limitExceeded && !fromFrozenDropzone ) {
            dropzoneFrozen[0].classList.add('dropzone-disable');
            dropzoneLocked[0].classList.add('dropzone-disable');
            return false;
          }
        },
        onEnd: function (event) {
          dropzoneFrozen[0].classList.remove('dropzone-disable');
          dropzoneLocked[0].classList.remove('dropzone-disable');

          var newPosition = event.newIndex;
          var oldPosition = event.oldIndex;
          var frozenDropzone = event.to.classList.contains('dropzone-frozen');

          if( !frozenDropzone ) {
            newPosition += dropzoneFrozen[0].querySelectorAll('.dropdown-item').length + gridInstance.colsLocked.length;
          } else {
            newPosition += gridInstance.colsLocked.length;
          }

          gridInstance.sortColumn(event.item.getAttribute("data-value"), newPosition, frozenDropzone);
        }
      }
      
      new Sortable(dropzoneFrozen[0], dropSettings);
      new Sortable(dropzoneDefrosted[0], dropSettings);
    },
    trigger: function(event) {
      if( this.loadUserSettingsDone == false ) {
        return;
      }

       this.$nextTick(() => {
        switch (event) {
          case 'update':
            this.onUpdate(this);
            break;
          case 'complete':
            this.onComplete(this);
            break;
          case 'mount':
            this.onMount(this);
            break;
          case 'beforeFetch':
            this.onBeforeFetch(this);
            break;
          case 'completeLazyRow':
            this.onCompleteLazyRow(this);
            break;
          case 'completeChildrenRow':
            this.onCompleteChildrenRow(this);
            break;
          default:
        }
        
        window.dispatchEvent(new Event('resize'));
      });
    }
  },

  created () {
    this.loadUserSettings();
  },
  mounted () {
    this.$refs.wrapper.style.paddingTop = this.$refs.head.offsetHeight + "px";
    
    this.$refs.movableBody.addEventListener('scroll', this.handleBodyScroll);
    window.addEventListener('scroll', this.handleWindowScroll);
    
    if( this.formEl ) {
      this.formEl.addEventListener("submit", this.handleFormSubmit, false);
    }

    if( this.autoload == true ) {
      this.fetchRows();
    }

    this.dragColumns();

    this.trigger('mount');
  },
  updated () {
    // console.log(this, new Date().getTime());
  },
  destroyed () {
    var movableBody =  this.$refs.movableBody;

    movableBody.removeEventListener('scroll', this.handleBodyScroll);
    window.removeEventListener('scroll', this.handleWindowScroll);

    if( this.formEl ) {
      this.formEl.removeEventListener("submit", this.handleFormSubmit, false);
    }
  },

  watch: {
    params: {
      handler: function(n, o) {
        this.fetchRows();
      },
      deep: true  
    },
    currentPage: function () {
      this.fetchRows();
      this.counterStart = this.currentPage == 1 ? 1 : ((this.currentPage-1) * this.pageSize) + 1;
    },
    orderKey: function () {
      this.fetchRows();
    },
    orderSort: function () {
      this.fetchRows();
    },
    pageSize: function (antigo, novo) {
      if( this.loadUserSettingsDone ) {
        this.fetchRows();
      }

      this.saveUserSettings();
    },
    sm: function () {
      this.rowHeight = 0;
      this.resize();
      this.saveUserSettings();
    },
    bordered: function () {
      this.saveUserSettings();
    },
    striped: function() {
      this.saveUserSettings();
    },
    hiddenColumns: function() {
      this.saveUserSettings();
      this.trigger('update');
    },
    frozenColumns: function() {
      // this.saveUserSettings();
    },
    colsOrder: function() {
      this.saveUserSettings();
      this.trigger('update');
    },
    counter: function() {
      this.saveUserSettings();
    },
    rows: function() {
      this.resize();
      this.trigger('update');
    },
    checkedAll: function() {
      if( this.checkedAll == true ) {
        this.checkedRows =  this.rows;
      } else {
        this.checkedRows = [];
      }
    },
    selectedRows: function() {

    },
    fullscreen: function() {
      if( this.fullscreen ) {
        document.body.style.overflowY = "hidden";
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
      } else {
        document.body.style.overflowY = "visible";
      }

      this.saveUserSettings();
    },
    fullwidth: function() {
      this.containerClass = this.fullwidth ? 'container-fluid' : 'container';
      this.resize();
      this.saveUserSettings();
    }
  },
  template: `
  <div class="gds-grid" id="gds-grid" :class="{'fullscreen': fullscreen}">
  <div class="g-totals container" v-if="$scopedSlots.totals">
    <h2 class="h6 text-uppercase mt-3">Total</h2>
    <slot name="totals" :data="responseData" :formData="formData"></slot>
  </div>
  <div class="g-container" :class="containerClass">
    <div class="g-header">
      <div class="g-header-info">
        <slot name="title"><h2 class="g-title h6 text-uppercase">{{ title }}</h2></slot>
      </div>
      <div class="g-header-actions">
        <slot :checkedRows="checkedRows" :checkedRowsIds="checkedRowsIds" name="toolbar"></slot>
        <div class="btn-group" v-if="$scopedSlots.export">
          <button type="button" class="btn btn-outline-secondary dropdown-toggle" data-toggle="dropdown-fixed" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-share-square"></i> Exportar
          </button>
          <div class="dropdown-menu" :class="{ 'dropdown-menu-right': screenWidth >= 768 }">
            <slot name="export"></slot>
          </div>
        </div>
        <div class="btn-group" v-if="!simpleGrid">
          <button type="button" class="btn btn-outline-secondary dropdown-toggle" data-toggle="dropdown-fixed" aria-haspopup="true" aria-expanded="false">
          <i class="fas fa-filter"></i> Colunas
          </button>
          <div class="dropdown-menu g-dropdown" :class="{ 'dropdown-menu-right': screenWidth >= 768 }" ref="dropdown">
            <div class="dropdown-locked-items">
              <div class="dropdown-item disabled" v-for="(col, i) in colsDropdown" v-if="col.freeze && col.lock">
                <span class="dropdown-label">
                  <i class="fas fa-lock"></i>
                  {{ col.text }}
                </span>
                <span class="dropdown-actions">
                  <!-- <i :class="{'fad fa-eye-slash': col.hidden, 'fas fa-eye': !col.hidden, 'invisible' : lockFilterVisibleColumn(col) }" @click="toggleColumns(col)"></i> -->
                </span>
              </div>
            </div>
            <div class="dropdown-dropzone dropzone-frozen">
              <div class="dropdown-item" v-for="(col, i) in colsDropdown" v-if="col.freeze && !col.lock" :data-value="col.value">
                <span class="dropdown-label">
                  <i class="far fa-arrows"></i>
                  {{ col.text }}
                </span>
                <span class="dropdown-actions">
                  <i :class="{'fad fa-eye-slash': col.hidden, 'fas fa-eye': !col.hidden, 'invisible' : lockFilterVisibleColumn(col) }" @click="toggleColumns(col)"></i>
                </span>
              </div>
            </div>
            <div class="dropdown-divider"></div>
            <div class="dropdown-dropzone dropzone-defrosted">
              <div class="dropdown-item" v-for="(col, i) in colsDropdown" v-if="!col.freeze" :class="{'disabled': col.lock }" :data-value="col.value">
                <span class="dropdown-label">
                  <i class="far fa-arrows"></i>
                  {{ col.text }}
                </span>
                <span class="dropdown-actions">
                  <i :class="{'fad fa-eye-slash': col.hidden, 'fas fa-eye': !col.hidden, 'invisible' : lockFilterVisibleColumn(col) }" @click="toggleColumns(col)"></i>
                </span>
              </div>
            </div>
          </div>
        </div>
        <div class="btn-group" v-if="!simpleGrid">
          <button type="button" class="btn btn-outline-secondary dropdown-toggle" data-toggle="dropdown-fixed" aria-haspopup="true" aria-expanded="false">
            <i class="far fa-sliders-h"></i> <span class="g-settings-text">Tabela</span>
          </button>
          <div class="dropdown-menu" :class="{ 'dropdown-menu-right': screenWidth >= 768 }">
            <div class="dropdown-item">
              <div class="custom-control custom-switch">
                <input type="checkbox" class="custom-control-input" id="fullwidth" v-model="fullwidth">
                <label class="custom-control-label" for="fullwidth">Expandir tabela</label>
              </div>
            </div>
            <div class="dropdown-item">
              <div class="custom-control custom-switch">
                <input type="checkbox" class="custom-control-input" id="sm" v-model="sm">
                <label class="custom-control-label" for="sm">Reduzir espaçamento</label>
              </div>
            </div>
            <div class="dropdown-item">
              <div class="custom-control custom-switch">
                <input type="checkbox" class="custom-control-input" id="bordered" v-model="bordered">
                <label class="custom-control-label" for="bordered">Adicionar linhas</label>
              </div>
            </div>
            <div class="dropdown-item" v-if="groupBy.length == 0">
              <div class="custom-control custom-switch">
                <input type="checkbox" class="custom-control-input" id="striped" v-model="striped">
                <label class="custom-control-label" for="striped">Adicionar contraste</label>
              </div>
            </div>
            <div class="dropdown-item">
              <div class="custom-control custom-switch">
                <input type="checkbox" class="custom-control-input" id="counter" v-model="counter">
                <label class="custom-control-label" for="counter">Numerar registros</label>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="g-wrapper" ref="wrapper">
      <div class="g-head" ref="head" :class="{ fixed: fixedHead, absolute: !fixedHead }" :style="{ 'width': wrapperWidth }">
        <div class="g-head-content" :style="{ 'padding-right': $scopedSlots.actions ? (actionsWidth + 'px') : 0 }">
          <div class="g-frozen-head" v-if="frozenColumns.length || checkboxAll">
            <table class="g-table table" :class="getTableClass()" :style="{ width : getTableWidth(frozenColumns) }">
              <thead class="thead-dark"> 
                <th class="g-th g-th-counter" :width="50" v-if="counter"><i class="far fa-sort-numeric-down"></i></th>
                <th v-if="checkboxAll" class="g-th g-th-all" :width="40">
                  <div class="custom-control custom-checkbox custom-control-labelless">
                    <input id="checkbox-all" type="checkbox" class="custom-control-input" v-model="checkedAll" />
                    <label class="custom-control-label" for="checkbox-all"></label>
                  </div>
                </th>
                <th class="g-th" v-for="(col, i) in cols" v-if="isVisibleCol(col) && col.freeze" :class="[col.class, {'orderable': col.orderable && rows.length > 0}]" :width="col.width ? col.width : column.width" @click="orderBy(col)">
                  <i :class="orderClass(col)" v-if="col.orderable"></i> <span class="g-th-text" v-html="col.text"></span>
                </th>
              </thead>
            </table>
          </div>
          <div class="g-movable-head" ref="movableHead">
            <table class="g-table table" :class="getTableClass()" :style="{ width : getTableWidth(defrostedColumns()) }">
              <thead class="thead-dark">
                <tr>
                  <th class="g-th" v-for="(col, i) in cols" v-if="isVisibleCol(col) && !col.freeze" :class="[col.class, {'orderable': col.orderable & rows.length > 0}]" :width="col.width ? col.width : column.width" @click="orderBy(col)">
                    <i :class="orderClass(col)" v-if="col.orderable"></i> <span class="g-th-text" v-html="col.text"></span>
                  </th>
                </tr>
              </thead>
            </table>
          </div>
          <div class="g-actions-head" v-if="$scopedSlots.actions">
            <table class="g-table table" :class="getTableClass()" :style="{ width: actionsWidth + 'px' }">
              <thead class="thead-dark">
                <tr>
                  <th class="th" :width="actionsWidth">
                    <span class="g-th-text">&nbsp;</span>
                  </th>
                </tr>
              </thead>
            </table>
          </div>
        </div>
        <div class="g-loader" v-show="!loadingDone"></div>
      </div>
      <div class="g-body">
        <div class="g-body-content" :style="{ 'padding-right': $scopedSlots.actions ? (actionsWidth + 'px') : 0 }" :class="{ 'loading': !loadingDone }">
          <div class="g-frozen-body" :class="{ scrolled : bodyScrolledRight }" v-if="frozenColumns.length || checkboxAll"  ref="frozenBody">
            <table class="g-table table" :class="getTableClass()" :style="{ width : getTableWidth(frozenColumns) }">
              <colgroup>
                <col :width="50" v-if="counter">
                <col :width="40" v-if="checkboxAll">
                <col v-for="col in cols" :style="{ width: (col.width ? col.width : column.width) + 'px' }"  v-if="isVisibleCol(col) && col.freeze">
              </colgroup>
              <tbody>
                <tr v-for="(row, i) in rows" class="g-tr" :class="getRowClass(row, i)"  @mouseover="rowHover = i"  @mouseleave="rowHover = -1" @dblclick="selectRow(row)" :height="rowHeight" :key="row.id">
                  <td class="g-td g-td-counter" v-if="counter">
                    <span v-if="!row.isChildren">{{ i + counterStart }}</span>
                  </td>
                  <td v-if="checkboxAll" class="g-td g-td-all">
                    <div class="custom-control custom-checkbox custom-control-labelless">
                      <input :id="'checkbox-row-' + row.id" type="checkbox" class="custom-control-input" v-model="checkedRows" :value="row" />
                      <label class="custom-control-label" :for="'checkbox-row-' + row.id"></label>
                    </div>
                  </td>
                  <td class="g-td" v-for="(col, i) in cols" :class="[col.class, { 'lazy' : col.lazy && !row.lazyDone }, { 'overflow': col.overflow }]" v-if="isVisibleCol(col) && col.freeze" @mouseenter="expandCell($event, false)" @mouseleave="unfoldCell">
                      <i class="fas" :class="{ 'fa-chevron-down': !row.expanded, 'fa-chevron-up': row.expanded  }" v-if="childrensUrl && !row.isChildren && i == 0"></i>
                      <slot v-if="!row.isParent" name="cell" :row="row" :col="col">
                        <span v-if="!col.html" class="g-td-text" v-show="!col.lazy || row.lazyDone">{{ row[col.value] }}</span>
                        <div v-else class="g-td-html" v-show="!col.lazy || row.lazyDone" v-html="row[col.value]"></div>
                      </slot>
                      <span clsss="g-parent-label" v-if="row.isParent && i == 0"><slot name="parent" :row="row" :col="col">{{ row.label }}</slot></span>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <div class="g-movable-body" ref="movableBody">
            <table class="g-table table" :class="getTableClass()" :style="{ width : getTableWidth(defrostedColumns()) }">
              <colgroup>
                <col v-for="col in cols" :style="{ width: (col.width ? col.width : column.width) + 'px' }"  v-if="isVisibleCol(col) && !col.freeze">
              </colgroup>
              <tbody>
                <tr v-for="(row, i) in rows" class="g-tr" :class="getRowClass(row, i)" @mouseover="rowHover = i"  @mouseleave="rowHover = -1" @dblclick="selectRow(row)" :height="rowHeight" :key="row.id">
                  <td class="g-td" v-for="(col, y) in cols" :class="[col.class, { 'lazy' : col.lazy && !row.lazyDone }, { 'overflow': col.overflow }]"  v-if="isVisibleCol(col) && !col.freeze" @mouseenter="expandCell($event, true)" @mouseleave="unfoldCell">
                    <slot v-if="!row.isParent" name="cell" :row="row" :col="col">
                      <span v-if="!col.html" class="g-td-text" v-show="!col.lazy || row.lazyDone" v-html="row[col.value]"></span>
                      <div v-else class="g-td-html" v-show="!col.lazy || row.lazyDone" v-html="row[col.value]"></div>
                    </slot>
                    <span classs="g-parent-label" v-if="row.isParent && y == 0 && frozenColumns.length == 0">{{ row.label }}</span>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <div class="g-actions-body" :class="{ scrolled : bodyScrolledLeft }" v-if="$scopedSlots.actions" ref="actionsBody">
            <table class="g-table table" :class="getTableClass()" :style="{ width: actionsWidth + 'px' }">
                <tbody>
                  <tr v-for="(row, i) in rows" class="g-tr" :class="getRowClass(row, i)"  @mouseover="rowHover = i"  @mouseleave="rowHover = -1" :height="rowHeight">
                    <td class="g-td g-td-action" width="50">
                      <div class="dropdown" v-if="!row.isParent">
                        <button class="btn btn-link p-0 px-1 dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                          <i class="fas fa-ellipsis-v"></i>
                        </button>
                        <div class="dropdown-menu dropdown-menu-right">
                          <slot name="actions" :row="row"><div class="dropdown-item">Nenhuma ação disponível</div></slot>
                        </div>
                      </div>
                    </td>
                  </tr>
                </tbody>
            </table>
          </div>
        </div>
        <p v-if="displayError" class="g-message">{{ errorMessage.title }} <small class="text-muted d-block">{{ errorMessage.subtitle }}</small></p>
        <p v-else-if="autoload == false && rowsWasFetched == false" class="g-message">{{ autoloadMessage.title }} <small class="text-muted d-block">{{ autoloadMessage.subtitle }}</small></p>
        <p v-else-if="rows.length == 0 && loadingDone == true" class="g-message">{{ emptyMessage.title }} <small class="text-muted d-block">{{ emptyMessage.subtitle }}</small></p>
        <p v-else-if="rows.length == 0 && loadingDone == false" class="g-message">{{ loadingMessage.title }} <small class="text-muted d-block">{{ loadingMessage.subtitle }}</small></p>
      </div>
    </div>
    <div class="g-footer">
      <div class="g-footer-left">
        <div class="g-footer-legend" v-if="$scopedSlots.legend">
          <slot name="legend"></slot>
        </div>
      </div>
      <div class="g-footer-right" v-if="pagination && rows.length > 0">
        <div class="g-footer-info">
          <!-- Exibindo {{ ((currentPage-1) * pageSize) + 1 }}-{{ (currentPage * pageSize) > totalData ? totalData : currentPage * pageSize }} de {{ totalData }} registros -->
          {{ currentPage }} de {{ totalPages }}
        </div>
        <div class="g-footer-actions">
          <select class="custom-select g-pagesize" v-model="pageSize" @change="currentPage = 1">
            <option v-for="pageSizeItem in pageSizeItems" :value="pageSizeItem">{{ pageSizeItem }}</option>
          </select>
          <nav class="g-pagination">
            <ul class="pagination">
              <li class="page-item" :class="{ disabled: currentPage == 1 }"><button type="button" class="page-link" @click="firstPage"><i class="fas fa-angle-double-left"></i></button></li>
              <li class="page-item" :class="{ disabled: currentPage == 1 }"><button type="button" class="page-link" @click="prevPage"><i class="fas fa-angle-left"></i></button></li>
              <li class="page-item" v-for="pageLink in pageLinks()" :class="{ 'active': pageLink.isCurrent }"><button type="button" class="page-link" @click="currentPage = pageLink.number" >{{ pageLink.number }}</button></li>
              <li class="page-item" :class="{ disabled: currentPage == totalPages }"><button type="button" class="page-link" @click="nextPage"><i class="fas fa-angle-right"></i></button></li>
              <li class="page-item" :class="{ disabled: currentPage == totalPages }"><button type="button" class="page-link" @click="lastPage"><i class="fas fa-angle-double-right"></i></button></li>
            </ul>
          </nav>
        </div>
      </div>
    </div>
  </div>
</div>
  `
});

// Polyfill foreach NodeList
if (window.NodeList && !NodeList.prototype.forEach) {
  NodeList.prototype.forEach = function (callback, thisArg) {
      thisArg = thisArg || window;
      for (var i = 0; i < this.length; i++) {
          callback.call(thisArg, this[i], i, this);
      }
  };
}